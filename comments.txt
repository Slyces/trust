Constantes
| N        | nombre de rounds              | 50           |
| H        | history size                  | 10           |
| Î»        | recency scaling factor        | - 5 / ln(.5) |

| Î·_BF     | branching factor              | 2            |
| Î·_RL     | referral max length           | 5            |

| Î±_min    | espace de l'activity level    | 0.25         |
| Î±_max    |                               | 1.00         |

| ug_min   | utilitÃ© minimale              | -10          |
| ug_max   | ---   maximale                | -10          |

| r_cons   | r_o consumer                  | ??           |
| r_prov   | r_o provider                  | ??           |

| PL_perf  | palier perfect                | 10           |
| PL_good  | --   good                     | 10           |
| PL_ok    | --   ok                       | 10           |
| PL_bad   | --   bad                      | 10           |
| PL_worst | --   worst                    | 10           |

| Np       | #Providers                    | 100          |
| Npg      | - Good                        | 10           |
| Npo      | - Ordinary                    | 40           |
| Npb      | - Bad                         | 5            |
| Npi      | - Intermitent                 | 45           |
| Nc       | #Consumer                     | 500          |

| W_I      | Poids InteractionsÂ            | 2.0Â          |
| W_R      |  ---  RolesÂ                   | 2.0Â          |
| W_W      |  ---  WitnessesÂ               | 1.0Â          |
| W_C      |  ---  Certificats             | 0.5Â          |

| Î³_I      | constante gamma               | - ln(.5)     |
| Î³_R      |                               | - ln(.5)     |
| Î³_W      |                               | - ln(.5)     |
| Î³_C      |                               | - ln(.5)     |

| p_ppc    | %max nouveaux provider        | 2%           |
| p_cpc    | %max    --    consumer        | 5%           |

| p_plp    | proba qu'un provider bouge    | 10%          |
| p_plc    | ---  -- -- consumer  ---      | 10%          |
| Î”Î¦_pÂ     | borne dÃ©placement providerÂ    | Â Ï€ / 20      |
| Î”Î¦_cÂ     | ---      ----    consumerÂ     | Â Ï€ / 20      |

| p_Î¼c     | proba de changement de Î¼      | 10%          |
| M        | Î”Î¼ max                        | 1.0          |
| p_pr_sw  | proba de changement de profil | 2%           |

Fonctions utilitaires
  - U(a, b) : flotant alÃ©atoire entre a et b inclus
  - G(Î¼, Ïƒ) : variable alÃ©atoire suivant une loi normale N(Î¼, Ïƒ)
  - d(a, b) : distance euclidienne entre a et b (oÃ¹ a = (ax, ay, az))
              simplification depuis la distance Ã  la surface d'une sphÃ¨re [@H]
  - r_choice(L) : retourne un Ã©lÃ©ment alÃ©atoire de L
  - rand(p) : retourne vrai avec une probabilitÃ© p
  - register(L, T) : enregistre le tuple T dans la liste L
      si L n'est pas plein
         ajouter T
      sinon
         supprimer l'entrÃ©e (a, b, v, t) avec t minimal
  - register_best(L, T) : enregistre le tuple T s'il est meilleur que
                          le moins bon tuple de L
      si T(v) > min(T'(v)) âˆ€ T' âˆˆ L
         ajouter T Ã  la place de T' le min
  - curr_t(void) : rÃ©cupÃ©rer le round en cours
  - t(r) : renvoie le round oÃ¹ un rating a Ã©tÃ© crÃ©Ã©
  - near_providers(a) : donne les providers dispo pour l'agent a [@H]
      retourner les providers p tq d(a, p) < a.r_o
  - near_consumers(a) : donne les providers dispo pour l'agent a
      retourner les consumers c tq d(a, c) < a.r_o
  - T(t) : 1 / t : tempÃ©rature pour l'exploration de Boltzmann [@H]


Initialisation Consumer
  - (x, y, z) alÃ©atoire uniforme Ã  la surface de la sphÃ¨re [@H]
  - r_o = r_cons
  - Î± = U(Î±_min, Î±_max)
  - ug_sum = 0 : somme des ug gagnÃ©s    depuis le dÃ©but
  - ug_n = 0   : nombre d'intÃ©ractions  ------ -- -----
  - ug_mean(void): renvoie l'ug moyen dur toutes les transactions [@H]
      return ug_sum / ug_n
  - L = liste de taille H contentant des Ã©lÃ©ments de forme
      (a, b, r, t) : a = agent consumer
                     b = agent provider
                     r = valeur de l'interaction
                     t = temps en round
      simplification depuis (a, b, c, i, r) car c unique et i non-utilisÃ© [@H]
  - val(ug) : valuation de l'UG pour a
       return ug / 10

Initialisation Provider
  - Type parmi : (good, ordinary, bad, intermitent)
  - L = liste de taille  H (voir consumer)
  - case(type) :
     good     : Î¼ = U(PL_good, PL_perf) [@H]
                Ïƒ = 1.0
     ordinary : Î¼ = U(PL_ok, PL_good)
                Ïƒ = 1.0
     bad      : Î¼ = U(PL_worst, PL_ok)
                Ïƒ = 2.0
  - r_o = r_prov
  - provide(void) : fonction
     si type âˆˆ (good, ordinary, bad)
         renvoie Î¼       (simplification de G(Î¼, Ïƒ) ) [@H]
     sinon
         renvoie U(PL_bad, PL_good)

Interaction(a, b) : a consumer, b provider
   ug = b.provide()   rÃ©cupÃ©rer l'ug de b
   a.ug_n += 1
   a.ug_sum += ug
   v = val(ug)
   r = (a, b, v, current_round())
   register(a.L, r)         | pseudocode, mais essayer de
   register_best(b.L, r)    | prendre en compte la simultanÃ©itÃ©

Choix d'un provider : a consumer
   P = near_providers(a)
   T_max = -1
   p_max = âˆ…
   trusted = âˆ…
   not_trusted = âˆ…
   âˆ€ p âˆˆ P
      T_p = Trust(a, p)
      si T_p â‰  âˆ…
         add(trusted, (p, T_p))
         si T_p > T_max:
             T_max = T_p
             p_max = p
      sinon
         add(not_trusted, p)
   err_profit  = exp( T_max / T(t) )
   err_explore = exp( val(ug_mean()) / T(t) ) [@H]
   p_expl = err_expl / (err_expl + err_profit)
   if rand(p_expl) :
       return r_choice(not_trusted)
   else
       return p_max

@TODO : rechercher la valeur de T (Boltzmann exploration strategy)
        on part sur du ( 1 / t )

fonction Ï‰_I, Ï‰_W, Ï‰_C: r un rating (a, b, c, i, v)
  Î”t(r) = curr_t - t(r)
  return exp(- Î”t / Î» )

function Ï‰_R : r un rating (a, b, c, e, v)
  return e

Calcul de T_I, T_W, T_C: ensemble de rating R
  Î£Ï‰ğ‘£ = 0
  Î£Ï‰ = 0
  âˆ€ r âˆˆ R:
      Î£Ï‰ğ‘£ += Ï‰_I(r) * r.ğ‘£
      Î£Ï‰ = Ï‰_I(r)
  T_K = Î£Ï‰ğ‘£ / Î£Ï‰
  Ï_RK = 1 - exp(-Î³_K * Î£Ï‰)
  âˆ€ r âˆˆ R:
      Î£Ï‰ğ‘£ğ‘‡ += Ï‰_I(r) * |r.ğ‘£ - T_K|
  Ï_DK = 1 - 0.5 * ( Î£Ï‰ğ‘£ğ‘‡  / Î£Ï‰ )
  Ï_K = Ï_RK * Ï_DK
  return (T_K, Ï_K)

Calcul de Trust: consumer a, provider b
  T_I, Ï_I = T_K(R_I(a, b))
  T_W, Ï_W = T_K(R_W(a, b))
  T_C, Ï_C = T_K(R_C(a, b))
  T_R, Ï_R = T_R(R_R(a, b)) : cas particulier
  Î£wT = W_I * Ï_I * T_I + W_W * Ï_W * T_W + W_C * Ï_C * T_C + W_R * Ï_R * T_R
  Î£w = W_I * Ï_I + W_W * Ï_W + W_C * Ï_C + W_R * Ï_R
  T = Î£wT / Î£ğ‘¤

-----------
Construction de R_I: consumer a, provider b
  return { r | r.b = b, t(r) < curr_t }
-----------
Meilleurs voisins: consumer a, provider b
  V = near_consumers(a)
  sort(V, dist(x, b))
  return Î·_BF meilleurs de V

Construction de R_W: consumer a, provider b
  visited = âˆ…
  R = âˆ… ;
  V = best_neighbors(a, b)
  nextV = âˆ…
  pour n = 1 -> Î·_RL
      âˆ€ v âˆˆ V:
          si v âˆ‰ visited:
              visited.add(v)
              RI_v = R_I(v, b)
              si R_I â‰  âˆ…:
                  merge(R, RI_v)
              sinon:
                  merge(V_next, best_neighbors(v, b))
      V = V_next
      V_next = âˆ…
  report R
-----------
Construction de R_C: consumer a, provider b
  return b.L
-----------
Construction de R_R: consumer a, provider b
  ??

Dynamisme de population :
  Î”prov = U(0, p_ppc)
  retirer (Î”prov * Np) random providers
  ajouter (Î”prov * Np) random providers (de mÃªme type ?) [@H]
                                        (de mÃªme distribution ?) [@H]
  Î”cons = U(0, p_cpc)
  retirer (Î”cons * Nc) random providers
  ajouter (Î”cons * Nc) random providers (de mÃªme type ?) [@H]
                                        (de mÃªme distribution ?) [@H]
  âˆ€ p âˆˆ population(providers):
      if rand(p_ps):
          changer le profil de p
          rÃ©initialiser Î¼_ğ‘, Ïƒ_ğ‘
      else if rand(p_Î¼ğ‘): [@H] (else if)
          Î”Î¼ = U(-M, +M)
          p.Î¼ = max(p.Î¼_min, min(p.Î¼_max, p.Î¼ + Î”_Î¼) ) [@H]
      if rand(p_plc):
          Î”Î¸ = U(âˆ’Î”Î¦, +Î”Î¦)
          Î”Ï† = U(âˆ’Î”Î¦, +Î”Î¦)
          p.Î¸ += Î”Î¸
          p.Ï† += Î”Ï†
  âˆ€ c âˆˆ population(consumers):
      if rand(p_clc):
          Î”Î¸ = U(âˆ’Î”Î¦, +Î”Î¦)
          Î”Ï† = U(âˆ’Î”Î¦, +Î”Î¦)
          c.Î¸ += Î”Î¸
          c.Ï† += Î”Ï†

nombre d'agent constant
proportion des catÃ©gories des provider page 139 on peut tirer sur une loi normale
est ce qu'on doit faire mourir et naitre des providers ?

